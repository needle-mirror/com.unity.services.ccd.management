//-----------------------------------------------------------------------------
// <auto-generated>
//     This file was generated by the C# SDK Code Generator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//-----------------------------------------------------------------------------


using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.Threading;
using UnityEngine.Networking;
using System.Threading.Tasks;
using Unity.Services.Ccd.Management.ErrorMitigation;
using Unity.Services.Ccd.Management.Helpers;
using Unity.Services.Ccd.Management.Scheduler;
using UnityEngine;
using Task = System.Threading.Tasks.Task;

namespace Unity.Services.Ccd.Management.Http
{
    /// <summary>
    /// HttpClient Class.
    /// </summary>
    internal class HttpClient : IHttpClient
    {
        private IRetryPolicyProvider _retryPolicy;
        private bool _logRequests;
        private bool _logRequestHeaders;

        /// <summary>Default Constructor.</summary>
        /// <param name="retryPolicy">The policy provider for backoff and retry.</param>
        /// <param name="logRequests">Log http requests</param>
        /// <param name="logRequestHeaders">Log http request headers</param>
        public HttpClient(IRetryPolicyProvider retryPolicy = null)
        {
            _retryPolicy = retryPolicy;
        }

        public void ConfigureLogging(bool logRequests = false, bool logRequestHeaders = false)
        {
            _logRequests = logRequests;
            _logRequestHeaders = logRequestHeaders;
        }

        /// <inheritdoc/>
        public async Task<HttpClientResponse> MakeRequestAsync(string method, string url, byte[] body,
            Dictionary<string, string> headers, int requestTimeout, RetryPolicyConfig retryPolicyConfig, StatusCodePolicyConfig statusCodesToRetry)
        {
            return await CreateWebRequestAsync(method.ToUpper(), url, body, headers, requestTimeout, retryPolicyConfig, statusCodesToRetry);
        }

        /// <inheritdoc/>
        public async Task<HttpClientResponse> MakeRequestAsync(string method, string url,
            List<IMultipartFormSection> body,
            Dictionary<string, string> headers, int requestTimeout, RetryPolicyConfig retryPolicyConfig, StatusCodePolicyConfig statusCodesToRetry, string boundary = null)
        {
            return await CreateWebRequestAsync(method.ToUpper(), url, body, headers, requestTimeout, retryPolicyConfig, statusCodesToRetry, boundary);
        }

        // Create and make an asynchronous UnityWebRequest
        private async Task<HttpClientResponse> CreateWebRequestAsync(string method, string url, byte[] body,
            IDictionary<string, string> headers, int requestTimeout, RetryPolicyConfig retryPolicyConfig, StatusCodePolicyConfig statusCodesToRetry)
        {
            if (_retryPolicy != null)
            {
                return await _retryPolicy
                    .ForOperation(CreateWebRequestFunction(method, url, body, headers, requestTimeout))
                    .WithRetryCondition(ShouldRetry(statusCodesToRetry))
                    .RunAsync(retryPolicyConfig);
            }
            else
            {
                return await CreateHttpClientResponse(method, url, body, headers, requestTimeout);
            }
        }

        private Func<int, Task<HttpClientResponse>> CreateWebRequestFunction(string method, string url, byte[] body, IDictionary<string, string> headers, int requestTimeout)
        {
            return async (attemptNumber) =>
            {
                return await CreateHttpClientResponse(method, url, body, headers, requestTimeout);
            };
        }

        private async Task<HttpClientResponse> CreateHttpClientResponse(string method, string url, byte[] body, IDictionary<string, string> headers,
            int requestTimeout)
        {
            var result = await await Task.Factory.StartNew(async () =>
                {
                    using (var request = new UnityWebRequest(url, method))
                    {
                        foreach (var header in headers)
                        {
                            request.SetRequestHeader(header.Key, header.Value);
                        }

                        request.timeout = requestTimeout;
                        if (body != null && (method == UnityWebRequest.kHttpVerbPOST ||
                                             method == UnityWebRequest.kHttpVerbPUT ||
                                             method == "PATCH"))
                        {
                            request.uploadHandler = new UploadHandlerRaw(body);
                        }

                        request.downloadHandler = new DownloadHandlerBuffer();
                        return await SendWebRequest(request);
                    }
                }, CancellationToken.None, TaskCreationOptions.None,
                Scheduler.ThreadHelper.TaskScheduler);
            LogVerbose(method, url, body, result);
            return result;
        }

        private static Func<HttpClientResponse, Task<bool>> ShouldRetry(StatusCodePolicyConfig statusCodesToRetry)
        {
            return (httpClientResponse)=>
            {
                if (statusCodesToRetry != null)
                {
                    return Task.FromResult(statusCodesToRetry.IsHandledStatusCode(httpClientResponse.StatusCode));
                }
                return Task.FromResult(false);
            };
        }

        // Create and make an asynchronous UnityWebRequest for a multipart body
        private async Task<HttpClientResponse> CreateWebRequestAsync(string method, string url,
            List<IMultipartFormSection> body,
            IDictionary<string, string> headers, int requestTimeout, RetryPolicyConfig retryPolicyConfig, StatusCodePolicyConfig statusCodesToRetry, string boundary = null)
        {
            var result = await await Task.Factory.StartNew(async () =>
                {
                    byte[] boundaryBytes = string.IsNullOrEmpty(boundary)
                        ? UnityWebRequest.GenerateBoundary()
                        : Encoding.Default.GetBytes(boundary);
                    var request = new UnityWebRequest(url, method);

                    foreach (var header in headers)
                    {
                        request.SetRequestHeader(header.Key, header.Value);
                    }

                    request.timeout = requestTimeout;
                    request = SetupMultipartRequest(request, body, boundaryBytes);
                    request.downloadHandler = new DownloadHandlerBuffer();

                    return await SendWebRequest(request);
                }, CancellationToken.None, TaskCreationOptions.None,
                Scheduler.ThreadHelper.TaskScheduler);
            LogVerbose(method, url, Encoding.UTF8.GetBytes("MultipartBody"), result);
            return result;
        }

        // Serialize the body of a multipart form request
        private static UnityWebRequest SetupMultipartRequest(UnityWebRequest request,
            List<IMultipartFormSection> multipartFormSections, byte[] boundary)
        {
            byte[] data = (byte[]) null;
            if (multipartFormSections != null && (uint) multipartFormSections.Count > 0U)
            {
                data = UnityWebRequest.SerializeFormSections(multipartFormSections, boundary);
            }

            UploadHandler uploadHandler = (UploadHandler) new UploadHandlerRaw(data);
            uploadHandler.contentType =
                "multipart/form-data; boundary=" + Encoding.UTF8.GetString(boundary, 0, boundary.Length);
            request.uploadHandler = uploadHandler;
            request.downloadHandler = (DownloadHandler) new DownloadHandlerBuffer();

            return request;
        }

        // Send a request
        private UnityWebRequestAsyncOperation SendWebRequest(UnityWebRequest request)
        {
            return request.SendWebRequest();
        }

        private void LogVerbose(string method, string url, byte[] body, HttpClientResponse result)
        {
            if (!_logRequests)
            {
                return;
            }

            var msg = new StringBuilder($"{method}[{result.StatusCode}] {result.ErrorMessage} {url}");
            if (body != null)
            {
                msg.Append($"\n\tRequest Body: {Encoding.UTF8.GetString(body, 0, body.Length)}");
            }
            if (result.Data.Length > 0)
            {
                msg.Append($"\n\tResponse Body: {Encoding.UTF8.GetString(result.Data, 0, result.Data.Length)}");
            }

            LogRequestHeaders(result, msg);

            if (result.StatusCode >= 500)
            {
                Debug.LogError(msg.ToString());
            }
            else if (result.StatusCode >= 400)
            {
                Debug.LogWarning(msg.ToString());
            }
            else
            {
                Debug.Log(msg.ToString());
            }
        }

        public void LogRequestHeaders(HttpClientResponse result, StringBuilder msg)
        {
            if (!_logRequestHeaders)
            {
                return;
            }

            msg.Append("\n\tHeaders:");
            foreach (var header in result.Headers)
            {
                msg.Append($"\n\t\t{header.Key}: {header.Value}");
            }
        }
    }
}
